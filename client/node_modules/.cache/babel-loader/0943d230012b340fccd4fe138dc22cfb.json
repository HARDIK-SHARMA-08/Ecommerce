{"ast":null,"code":"var _toConsumableArray = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _objectSpread = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _slicedToArray = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _classCallCheck = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _objectWithoutProperties = require(\"E:\\\\Web Development\\\\Ecommerce\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar $goTMa$reactariautils = require(\"@react-aria/utils\");\nvar $goTMa$react = require(\"react\");\nvar $goTMa$swchelperscjs_class_private_field_getcjs = require(\"@swc/helpers/cjs/_class_private_field_get.cjs\");\nvar $goTMa$swchelperscjs_class_private_field_initcjs = require(\"@swc/helpers/cjs/_class_private_field_init.cjs\");\nvar $goTMa$swchelperscjs_class_private_field_setcjs = require(\"@swc/helpers/cjs/_class_private_field_set.cjs\");\nvar $goTMa$reactariassr = require(\"@react-aria/ssr\");\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n$parcel$export(module.exports, \"Pressable\", function () {\n  return $e1dbec26039c051d$export$27c701ed9e449e99;\n});\n$parcel$export(module.exports, \"PressResponder\", function () {\n  return $3596bae48579386f$export$3351871ee4b288b8;\n});\n$parcel$export(module.exports, \"ClearPressResponder\", function () {\n  return $3596bae48579386f$export$cf75428e0b9ed1ea;\n});\n$parcel$export(module.exports, \"useFocus\", function () {\n  return $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6;\n});\n$parcel$export(module.exports, \"isFocusVisible\", function () {\n  return $e77252a287ef94ab$export$b9b3dfddab17db27;\n});\n$parcel$export(module.exports, \"getInteractionModality\", function () {\n  return $e77252a287ef94ab$export$630ff653c5ada6a9;\n});\n$parcel$export(module.exports, \"setInteractionModality\", function () {\n  return $e77252a287ef94ab$export$8397ddfc504fdb9a;\n});\n$parcel$export(module.exports, \"useInteractionModality\", function () {\n  return $e77252a287ef94ab$export$98e20ec92f614cfe;\n});\n$parcel$export(module.exports, \"useFocusVisible\", function () {\n  return $e77252a287ef94ab$export$ffd9e5021c1fb2d6;\n});\n$parcel$export(module.exports, \"useFocusVisibleListener\", function () {\n  return $e77252a287ef94ab$export$ec71b4b83ac08ec3;\n});\n$parcel$export(module.exports, \"useFocusWithin\", function () {\n  return $d16842bbd0359d1b$export$420e68273165f4ec;\n});\n$parcel$export(module.exports, \"useHover\", function () {\n  return $ffbc150311c75f01$export$ae780daf29e6d456;\n});\n$parcel$export(module.exports, \"useInteractOutside\", function () {\n  return $edcfa848c42f94f4$export$872b660ac5a1ff98;\n});\n$parcel$export(module.exports, \"useKeyboard\", function () {\n  return $892d64db2a3c53b0$export$8f71654801c2f7cd;\n});\n$parcel$export(module.exports, \"useMove\", function () {\n  return $c09386fc48fa427d$export$36da96379f79f245;\n});\n$parcel$export(module.exports, \"usePress\", function () {\n  return $0294ea432cd92340$export$45712eceda6fad21;\n});\n$parcel$export(module.exports, \"useScrollWheel\", function () {\n  return $a3dbce0aed7087e2$export$2123ff2b87c81ca;\n});\n$parcel$export(module.exports, \"useLongPress\", function () {\n  return $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9;\n});\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nvar $f7e14e656343df57$var$state = \"default\";\nvar $f7e14e656343df57$var$savedUserSelect = \"\";\nvar $f7e14e656343df57$var$modifiedElementMap = new WeakMap();\nfunction $f7e14e656343df57$export$16a4697467175487(target) {\n  if ((0, $goTMa$reactariautils.isIOS)()) {\n    if ($f7e14e656343df57$var$state === \"default\") {\n      $f7e14e656343df57$var$savedUserSelect = document.documentElement.style.webkitUserSelect;\n      document.documentElement.style.webkitUserSelect = \"none\";\n    }\n    $f7e14e656343df57$var$state = \"disabled\";\n  } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n    // If not iOS, store the target's original user-select and change to user-select: none\n    // Ignore state since it doesn't apply for non iOS\n    $f7e14e656343df57$var$modifiedElementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n}\nfunction $f7e14e656343df57$export$b0d6fa1ab32e3295(target) {\n  if ((0, $goTMa$reactariautils.isIOS)()) {\n    // If the state is already default, there's nothing to do.\n    // If it is restoring, then there's no need to queue a second restore.\n    if ($f7e14e656343df57$var$state !== \"disabled\") return;\n    $f7e14e656343df57$var$state = \"restoring\";\n    // There appears to be a delay on iOS where selection still might occur\n    // after pointer up, so wait a bit before removing user-select.\n    setTimeout(function () {\n      // Wait for any CSS transitions to complete so we don't recompute style\n      // for the whole page in the middle of the animation and cause jank.\n      (0, $goTMa$reactariautils.runAfterTransition)(function () {\n        // Avoid race conditions\n        if ($f7e14e656343df57$var$state === \"restoring\") {\n          if (document.documentElement.style.webkitUserSelect === \"none\") document.documentElement.style.webkitUserSelect = $f7e14e656343df57$var$savedUserSelect || \"\";\n          $f7e14e656343df57$var$savedUserSelect = \"\";\n          $f7e14e656343df57$var$state = \"default\";\n        }\n      });\n    }, 300);\n  } else if (target instanceof HTMLElement || target instanceof SVGElement)\n    // If not iOS, restore the target's original user-select if any\n    // Ignore state since it doesn't apply for non iOS\n    {\n      if (target && $f7e14e656343df57$var$modifiedElementMap.has(target)) {\n        var targetOldUserSelect = $f7e14e656343df57$var$modifiedElementMap.get(target);\n        if (target.style.userSelect === \"none\") target.style.userSelect = targetOldUserSelect;\n        if (target.getAttribute(\"style\") === \"\") target.removeAttribute(\"style\");\n        $f7e14e656343df57$var$modifiedElementMap.delete(target);\n      }\n    }\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nvar $01d3f539e91688c8$export$5165eccb35aaadb5 = (0, $parcel$interopDefault($goTMa$react)).createContext(null);\n$01d3f539e91688c8$export$5165eccb35aaadb5.displayName = \"PressResponderContext\";\nfunction $0294ea432cd92340$var$usePressResponderContext(props) {\n  // Consume context from <PressResponder> and merge with props.\n  var context = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));\n  if (context) {\n    var register = context.register,\n      contextProps = _objectWithoutProperties(context, [\"register\"]);\n    props = (0, $goTMa$reactariautils.mergeProps)(contextProps, props);\n    register();\n  }\n  (0, $goTMa$reactariautils.useSyncRef)(context, props.ref);\n  return props;\n}\nvar $0294ea432cd92340$var$_shouldStopPropagation = /*#__PURE__*/new WeakMap();\nvar $0294ea432cd92340$var$PressEvent = /*#__PURE__*/function () {\n  \"use strict\";\n\n  _createClass($0294ea432cd92340$var$PressEvent, [{\n    key: \"continuePropagation\",\n    value: function continuePropagation() {\n      (0, $goTMa$swchelperscjs_class_private_field_setcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, false);\n    }\n  }, {\n    key: \"shouldStopPropagation\",\n    get: function get() {\n      return (0, $goTMa$swchelperscjs_class_private_field_getcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation);\n    }\n  }]);\n  function $0294ea432cd92340$var$PressEvent(type, pointerType, originalEvent) {\n    _classCallCheck(this, $0294ea432cd92340$var$PressEvent);\n    (0, $goTMa$swchelperscjs_class_private_field_initcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, {\n      writable: true,\n      value: void 0\n    });\n    (0, $goTMa$swchelperscjs_class_private_field_setcjs._)(this, $0294ea432cd92340$var$_shouldStopPropagation, true);\n    this.type = type;\n    this.pointerType = pointerType;\n    this.target = originalEvent.currentTarget;\n    this.shiftKey = originalEvent.shiftKey;\n    this.metaKey = originalEvent.metaKey;\n    this.ctrlKey = originalEvent.ctrlKey;\n    this.altKey = originalEvent.altKey;\n  }\n  return $0294ea432cd92340$var$PressEvent;\n}();\nvar $0294ea432cd92340$var$LINK_CLICKED = Symbol(\"linkClicked\");\nfunction $0294ea432cd92340$export$45712eceda6fad21(props) {\n  var _$0294ea432cd92340$va = $0294ea432cd92340$var$usePressResponderContext(props),\n    onPress = _$0294ea432cd92340$va.onPress,\n    onPressChange = _$0294ea432cd92340$va.onPressChange,\n    onPressStart = _$0294ea432cd92340$va.onPressStart,\n    onPressEnd = _$0294ea432cd92340$va.onPressEnd,\n    onPressUp = _$0294ea432cd92340$va.onPressUp,\n    isDisabled = _$0294ea432cd92340$va.isDisabled,\n    isPressedProp = _$0294ea432cd92340$va.isPressed,\n    preventFocusOnPress = _$0294ea432cd92340$va.preventFocusOnPress,\n    shouldCancelOnPointerExit = _$0294ea432cd92340$va.shouldCancelOnPointerExit,\n    allowTextSelectionOnPress = _$0294ea432cd92340$va.allowTextSelectionOnPress,\n    _ = _$0294ea432cd92340$va.ref,\n    domProps = _objectWithoutProperties(_$0294ea432cd92340$va, [\"onPress\", \"onPressChange\", \"onPressStart\", \"onPressEnd\", \"onPressUp\", \"isDisabled\", \"isPressed\", \"preventFocusOnPress\", \"shouldCancelOnPointerExit\", \"allowTextSelectionOnPress\", \"ref\"]);\n  var _ref = (0, $goTMa$react.useState)(false),\n    _ref2 = _slicedToArray(_ref, 2),\n    isPressed = _ref2[0],\n    setPressed = _ref2[1];\n  var ref = (0, $goTMa$react.useRef)({\n    isPressed: false,\n    ignoreEmulatedMouseEvents: false,\n    ignoreClickAfterPress: false,\n    didFirePressStart: false,\n    isTriggeringEvent: false,\n    activePointerId: null,\n    target: null,\n    isOverTarget: false,\n    pointerType: null\n  });\n  var _ref3 = (0, $goTMa$reactariautils.useGlobalListeners)(),\n    addGlobalListener = _ref3.addGlobalListener,\n    removeAllGlobalListeners = _ref3.removeAllGlobalListeners;\n  var triggerPressStart = (0, $goTMa$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var state = ref.current;\n    if (isDisabled || state.didFirePressStart) return;\n    var shouldStopPropagation = true;\n    state.isTriggeringEvent = true;\n    if (onPressStart) {\n      var event = new $0294ea432cd92340$var$PressEvent(\"pressstart\", pointerType, originalEvent);\n      onPressStart(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(true);\n    state.isTriggeringEvent = false;\n    state.didFirePressStart = true;\n    setPressed(true);\n    return shouldStopPropagation;\n  });\n  var triggerPressEnd = (0, $goTMa$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var wasPressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var state = ref.current;\n    if (!state.didFirePressStart) return;\n    state.ignoreClickAfterPress = true;\n    state.didFirePressStart = false;\n    state.isTriggeringEvent = true;\n    var shouldStopPropagation = true;\n    if (onPressEnd) {\n      var event = new $0294ea432cd92340$var$PressEvent(\"pressend\", pointerType, originalEvent);\n      onPressEnd(event);\n      shouldStopPropagation = event.shouldStopPropagation;\n    }\n    if (onPressChange) onPressChange(false);\n    setPressed(false);\n    if (onPress && wasPressed && !isDisabled) {\n      var _event = new $0294ea432cd92340$var$PressEvent(\"press\", pointerType, originalEvent);\n      onPress(_event);\n      shouldStopPropagation && (shouldStopPropagation = _event.shouldStopPropagation);\n    }\n    state.isTriggeringEvent = false;\n    return shouldStopPropagation;\n  });\n  var triggerPressUp = (0, $goTMa$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    var state = ref.current;\n    if (isDisabled) return;\n    if (onPressUp) {\n      state.isTriggeringEvent = true;\n      var event = new $0294ea432cd92340$var$PressEvent(\"pressup\", pointerType, originalEvent);\n      onPressUp(event);\n      state.isTriggeringEvent = false;\n      return event.shouldStopPropagation;\n    }\n    return true;\n  });\n  var cancel = (0, $goTMa$reactariautils.useEffectEvent)(function (e) {\n    var state = ref.current;\n    if (state.isPressed) {\n      if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n      state.isPressed = false;\n      state.isOverTarget = false;\n      state.activePointerId = null;\n      state.pointerType = null;\n      removeAllGlobalListeners();\n      if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);\n    }\n  });\n  var cancelOnPointerExit = (0, $goTMa$reactariautils.useEffectEvent)(function (e) {\n    if (shouldCancelOnPointerExit) cancel(e);\n  });\n  var pressProps = (0, $goTMa$react.useMemo)(function () {\n    var state = ref.current;\n    var pressProps = {\n      onKeyDown: function onKeyDown(e) {\n        if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n          if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n          // If the event is repeating, it may have started on a different element\n          // after which focus moved to the current element. Ignore these events and\n          // only handle the first key down event.\n          var shouldStopPropagation = true;\n          if (!state.isPressed && !e.repeat) {\n            state.target = e.currentTarget;\n            state.isPressed = true;\n            shouldStopPropagation = triggerPressStart(e, \"keyboard\");\n            // Focus may move before the key up event, so register the event on the document\n            // instead of the same element where the key down event occurred.\n            addGlobalListener(document, \"keyup\", onKeyUp, false);\n          }\n          if (shouldStopPropagation) e.stopPropagation();\n          // Keep track of the keydown events that occur while the Meta (e.g. Command) key is held.\n          // macOS has a bug where keyup events are not fired while the Meta key is down.\n          // When the Meta key itself is released we will get an event for that, and we'll act as if\n          // all of these other keys were released as well.\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1393524\n          // https://bugs.webkit.org/show_bug.cgi?id=55291\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=1299553\n          if (e.metaKey && (0, $goTMa$reactariautils.isMac)()) state.metaKeyEvents.set(e.key, e.nativeEvent);\n        } else if (e.key === \"Meta\") state.metaKeyEvents = new Map();\n      },\n      onKeyUp: function onKeyUp(e) {\n        if ($0294ea432cd92340$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($0294ea432cd92340$var$createEvent(state.target, e), \"keyboard\");\n      },\n      onClick: function onClick(e) {\n        if (e && !e.currentTarget.contains(e.target)) return;\n        if (e && e.button === 0 && !state.isTriggeringEvent && !(0, $goTMa$reactariautils.openLink).isOpening) {\n          var shouldStopPropagation = true;\n          if (isDisabled) e.preventDefault();\n          // If triggered from a screen reader or by using element.click(),\n          // trigger as if it were a keyboard click.\n          if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && !state.isPressed && (state.pointerType === \"virtual\" || (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent))) {\n            // Ensure the element receives focus (VoiceOver on iOS does not do this)\n            if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);\n            var stopPressStart = triggerPressStart(e, \"virtual\");\n            var stopPressUp = triggerPressUp(e, \"virtual\");\n            var stopPressEnd = triggerPressEnd(e, \"virtual\");\n            shouldStopPropagation = stopPressStart && stopPressUp && stopPressEnd;\n          }\n          state.ignoreEmulatedMouseEvents = false;\n          state.ignoreClickAfterPress = false;\n          if (shouldStopPropagation) e.stopPropagation();\n        }\n      }\n    };\n    var onKeyUp = function onKeyUp(e) {\n      var _state_metaKeyEvents;\n      if (state.isPressed && $0294ea432cd92340$var$isValidKeyboardEvent(e, state.target)) {\n        var _state_metaKeyEvents1;\n        if ($0294ea432cd92340$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n        var target = e.target;\n        var shouldStopPropagation = triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), \"keyboard\", state.target.contains(target));\n        removeAllGlobalListeners();\n        if (shouldStopPropagation) e.stopPropagation();\n        // If a link was triggered with a key other than Enter, open the URL ourselves.\n        // This means the link has a role override, and the default browser behavior\n        // only applies when using the Enter key.\n        if (e.key !== \"Enter\" && $0294ea432cd92340$var$isHTMLAnchorLink(state.target) && state.target.contains(target) && !e[$0294ea432cd92340$var$LINK_CLICKED]) {\n          // Store a hidden property on the event so we only trigger link click once,\n          // even if there are multiple usePress instances attached to the element.\n          e[$0294ea432cd92340$var$LINK_CLICKED] = true;\n          (0, $goTMa$reactariautils.openLink)(state.target, e, false);\n        }\n        state.isPressed = false;\n        (_state_metaKeyEvents1 = state.metaKeyEvents) === null || _state_metaKeyEvents1 === void 0 ? void 0 : _state_metaKeyEvents1.delete(e.key);\n      } else if (e.key === \"Meta\" && ((_state_metaKeyEvents = state.metaKeyEvents) === null || _state_metaKeyEvents === void 0 ? void 0 : _state_metaKeyEvents.size)) {\n        // If we recorded keydown events that occurred while the Meta key was pressed,\n        // and those haven't received keyup events already, fire keyup events ourselves.\n        // See comment above for more info about the macOS bug causing this.\n        var events = state.metaKeyEvents;\n        state.metaKeyEvents = null;\n        var _iterator = _createForOfIteratorHelper(events.values()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var event = _step.value;\n            state.target.dispatchEvent(new KeyboardEvent(\"keyup\", event));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    };\n    if (typeof PointerEvent !== \"undefined\") {\n      pressProps.onPointerDown = function (e) {\n        // Only handle left clicks, and ignore events that bubbled through portals.\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n        // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n        // Ignore and let the onClick handler take care of it instead.\n        // https://bugs.webkit.org/show_bug.cgi?id=222627\n        // https://bugs.webkit.org/show_bug.cgi?id=223202\n        if ((0, $goTMa$reactariautils.isVirtualPointerEvent)(e.nativeEvent)) {\n          state.pointerType = \"virtual\";\n          return;\n        }\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on pointer down and handle focusing the pressable element ourselves.\n        if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n        state.pointerType = e.pointerType;\n        var shouldStopPropagation = true;\n        if (!state.isPressed) {\n          state.isPressed = true;\n          state.isOverTarget = true;\n          state.activePointerId = e.pointerId;\n          state.target = e.currentTarget;\n          if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);\n          if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          addGlobalListener(document, \"pointermove\", onPointerMove, false);\n          addGlobalListener(document, \"pointerup\", onPointerUp, false);\n          addGlobalListener(document, \"pointercancel\", onPointerCancel, false);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseDown = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (e.button === 0) {\n          // Chrome and Firefox on touch Windows devices require mouse down events\n          // to be canceled in addition to pointer events, or an extra asynchronous\n          // focus event will be fired.\n          if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n          e.stopPropagation();\n        }\n      };\n      pressProps.onPointerUp = function (e) {\n        // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n        if (!e.currentTarget.contains(e.target) || state.pointerType === \"virtual\") return;\n        // Only handle left clicks\n        // Safari on iOS sometimes fires pointerup events, even\n        // when the touch isn't over the target, so double check.\n        if (e.button === 0 && $0294ea432cd92340$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n      };\n      // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n      // Use pointer move events instead to implement our own hit testing.\n      // See https://bugs.webkit.org/show_bug.cgi?id=199803\n      var onPointerMove = function onPointerMove(e) {\n        if (e.pointerId !== state.activePointerId) return;\n        if ($0294ea432cd92340$var$isOverTarget(e, state.target)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            triggerPressStart($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n      };\n      var onPointerUp = function onPointerUp(e) {\n        if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {\n          if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n          state.isPressed = false;\n          state.isOverTarget = false;\n          state.activePointerId = null;\n          state.pointerType = null;\n          removeAllGlobalListeners();\n          if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);\n        }\n      };\n      var onPointerCancel = function onPointerCancel(e) {\n        cancel(e);\n      };\n      pressProps.onDragStart = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n        cancel(e);\n      };\n    } else {\n      pressProps.onMouseDown = function (e) {\n        // Only handle left clicks\n        if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent\n        // default on mouse down and handle focusing the pressable element ourselves.\n        if ($0294ea432cd92340$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n        if (state.ignoreEmulatedMouseEvents) {\n          e.stopPropagation();\n          return;\n        }\n        state.isPressed = true;\n        state.isOverTarget = true;\n        state.target = e.currentTarget;\n        state.pointerType = (0, $goTMa$reactariautils.isVirtualClick)(e.nativeEvent) ? \"virtual\" : \"mouse\";\n        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);\n        var shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener(document, \"mouseup\", onMouseUp, false);\n      };\n      pressProps.onMouseEnter = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        var shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = true;\n          shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseLeave = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        var shouldStopPropagation = true;\n        if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onMouseUp = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType || \"mouse\");\n      };\n      var onMouseUp = function onMouseUp(e) {\n        // Only handle left clicks\n        if (e.button !== 0) return;\n        state.isPressed = false;\n        removeAllGlobalListeners();\n        if (state.ignoreEmulatedMouseEvents) {\n          state.ignoreEmulatedMouseEvents = false;\n          return;\n        }\n        if ($0294ea432cd92340$var$isOverTarget(e, state.target)) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType);else if (state.isOverTarget) triggerPressEnd($0294ea432cd92340$var$createEvent(state.target, e), state.pointerType, false);\n        state.isOverTarget = false;\n      };\n      pressProps.onTouchStart = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        var touch = $0294ea432cd92340$var$getTouchFromEvent(e.nativeEvent);\n        if (!touch) return;\n        state.activePointerId = touch.identifier;\n        state.ignoreEmulatedMouseEvents = true;\n        state.isOverTarget = true;\n        state.isPressed = true;\n        state.target = e.currentTarget;\n        state.pointerType = \"touch\";\n        // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n        // on the emulated mouse event and handle focusing the pressable element ourselves.\n        if (!isDisabled && !preventFocusOnPress) (0, $goTMa$reactariautils.focusWithoutScrolling)(e.currentTarget);\n        if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$16a4697467175487)(state.target);\n        var shouldStopPropagation = triggerPressStart(e, state.pointerType);\n        if (shouldStopPropagation) e.stopPropagation();\n        addGlobalListener(window, \"scroll\", onScroll, true);\n      };\n      pressProps.onTouchMove = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        var touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);\n        var shouldStopPropagation = true;\n        if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {\n          if (!state.isOverTarget) {\n            state.isOverTarget = true;\n            shouldStopPropagation = triggerPressStart(e, state.pointerType);\n          }\n        } else if (state.isOverTarget) {\n          state.isOverTarget = false;\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n          cancelOnPointerExit(e);\n        }\n        if (shouldStopPropagation) e.stopPropagation();\n      };\n      pressProps.onTouchEnd = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        if (!state.isPressed) {\n          e.stopPropagation();\n          return;\n        }\n        var touch = $0294ea432cd92340$var$getTouchById(e.nativeEvent, state.activePointerId);\n        var shouldStopPropagation = true;\n        if (touch && $0294ea432cd92340$var$isOverTarget(touch, e.currentTarget)) {\n          triggerPressUp(e, state.pointerType);\n          shouldStopPropagation = triggerPressEnd(e, state.pointerType);\n        } else if (state.isOverTarget) shouldStopPropagation = triggerPressEnd(e, state.pointerType, false);\n        if (shouldStopPropagation) e.stopPropagation();\n        state.isPressed = false;\n        state.activePointerId = null;\n        state.isOverTarget = false;\n        state.ignoreEmulatedMouseEvents = true;\n        if (!allowTextSelectionOnPress) (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(state.target);\n        removeAllGlobalListeners();\n      };\n      pressProps.onTouchCancel = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        e.stopPropagation();\n        if (state.isPressed) cancel(e);\n      };\n      var onScroll = function onScroll(e) {\n        if (state.isPressed && e.target.contains(state.target)) cancel({\n          currentTarget: state.target,\n          shiftKey: false,\n          ctrlKey: false,\n          metaKey: false,\n          altKey: false\n        });\n      };\n      pressProps.onDragStart = function (e) {\n        if (!e.currentTarget.contains(e.target)) return;\n        cancel(e);\n      };\n    }\n    return pressProps;\n  }, [addGlobalListener, isDisabled, preventFocusOnPress, removeAllGlobalListeners, allowTextSelectionOnPress, cancel, cancelOnPointerExit, triggerPressEnd, triggerPressStart, triggerPressUp]);\n  // Remove user-select: none in case component unmounts immediately after pressStart\n  // eslint-disable-next-line arrow-body-style\n  (0, $goTMa$react.useEffect)(function () {\n    return function () {\n      if (!allowTextSelectionOnPress)\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)(ref.current.target);\n    };\n  }, [allowTextSelectionOnPress]);\n  return {\n    isPressed: isPressedProp || isPressed,\n    pressProps: (0, $goTMa$reactariautils.mergeProps)(domProps, pressProps)\n  };\n}\nfunction $0294ea432cd92340$var$isHTMLAnchorLink(target) {\n  return target.tagName === \"A\" && target.hasAttribute(\"href\");\n}\nfunction $0294ea432cd92340$var$isValidKeyboardEvent(event, currentTarget) {\n  var key = event.key,\n    code = event.code;\n  var element = currentTarget;\n  var role = element.getAttribute(\"role\");\n  // Accessibility for keyboards. Space and Enter only.\n  // \"Spacebar\" is for IE 11\n  return (key === \"Enter\" || key === \" \" || key === \"Spacebar\" || code === \"Space\") && !(element instanceof HTMLInputElement && !$0294ea432cd92340$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) &&\n  // Links should only trigger with Enter key\n  !((role === \"link\" || !role && $0294ea432cd92340$var$isHTMLAnchorLink(element)) && key !== \"Enter\");\n}\nfunction $0294ea432cd92340$var$getTouchFromEvent(event) {\n  var targetTouches = event.targetTouches;\n  if (targetTouches.length > 0) return targetTouches[0];\n  return null;\n}\nfunction $0294ea432cd92340$var$getTouchById(event, pointerId) {\n  var changedTouches = event.changedTouches;\n  for (var i = 0; i < changedTouches.length; i++) {\n    var touch = changedTouches[i];\n    if (touch.identifier === pointerId) return touch;\n  }\n  return null;\n}\nfunction $0294ea432cd92340$var$createEvent(target, e) {\n  return {\n    currentTarget: target,\n    shiftKey: e.shiftKey,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey\n  };\n}\nfunction $0294ea432cd92340$var$getPointClientRect(point) {\n  var offsetX = point.width / 2 || point.radiusX || 0;\n  var offsetY = point.height / 2 || point.radiusY || 0;\n  return {\n    top: point.clientY - offsetY,\n    right: point.clientX + offsetX,\n    bottom: point.clientY + offsetY,\n    left: point.clientX - offsetX\n  };\n}\nfunction $0294ea432cd92340$var$areRectanglesOverlapping(a, b) {\n  // check if they cannot overlap on x axis\n  if (a.left > b.right || b.left > a.right) return false;\n  // check if they cannot overlap on y axis\n  if (a.top > b.bottom || b.top > a.bottom) return false;\n  return true;\n}\nfunction $0294ea432cd92340$var$isOverTarget(point, target) {\n  var rect = target.getBoundingClientRect();\n  var pointRect = $0294ea432cd92340$var$getPointClientRect(point);\n  return $0294ea432cd92340$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $0294ea432cd92340$var$shouldPreventDefault(target) {\n  // We cannot prevent default if the target is a draggable element.\n  return !(target instanceof HTMLElement) || !target.hasAttribute(\"draggable\");\n}\nfunction $0294ea432cd92340$var$shouldPreventDefaultKeyboard(target, key) {\n  if (target instanceof HTMLInputElement) return !$0294ea432cd92340$var$isValidInputKey(target, key);\n  if (target instanceof HTMLButtonElement) return target.type !== \"submit\" && target.type !== \"reset\";\n  if ($0294ea432cd92340$var$isHTMLAnchorLink(target)) return false;\n  return true;\n}\nvar $0294ea432cd92340$var$nonTextInputTypes = new Set([\"checkbox\", \"radio\", \"range\", \"color\", \"file\", \"image\", \"button\", \"submit\", \"reset\"]);\nfunction $0294ea432cd92340$var$isValidInputKey(target, key) {\n  // Only space should toggle checkboxes and radios, not enter.\n  return target.type === \"checkbox\" || target.type === \"radio\" ? key === \" \" : $0294ea432cd92340$var$nonTextInputTypes.has(target.type);\n}\nvar $e1dbec26039c051d$export$27c701ed9e449e99 = /*#__PURE__*/(0, $parcel$interopDefault($goTMa$react)).forwardRef(function (_ref4, ref) {\n  var children = _ref4.children,\n    props = _objectWithoutProperties(_ref4, [\"children\"]);\n  var newRef = (0, $goTMa$react.useRef)();\n  ref = ref !== null && ref !== void 0 ? ref : newRef;\n  var _ref5 = (0, $0294ea432cd92340$export$45712eceda6fad21)(_objectSpread({}, props, {\n      ref: ref\n    })),\n    pressProps = _ref5.pressProps;\n  var child = (0, $parcel$interopDefault($goTMa$react)).Children.only(children);\n  return /*#__PURE__*/(0, $parcel$interopDefault($goTMa$react)).cloneElement(child, // @ts-ignore\n  _objectSpread({\n    ref: ref\n  }, (0, $goTMa$reactariautils.mergeProps)(child.props, pressProps)));\n});\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nvar $3596bae48579386f$export$3351871ee4b288b8 = /*#__PURE__*/(0, $parcel$interopDefault($goTMa$react)).forwardRef(function (_ref6, ref) {\n  var children = _ref6.children,\n    props = _objectWithoutProperties(_ref6, [\"children\"]);\n  var isRegistered = (0, $goTMa$react.useRef)(false);\n  var prevContext = (0, $goTMa$react.useContext)((0, $01d3f539e91688c8$export$5165eccb35aaadb5));\n  var context = (0, $goTMa$reactariautils.mergeProps)(prevContext || {}, _objectSpread({}, props, {\n    ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),\n    register: function register() {\n      isRegistered.current = true;\n      if (prevContext) prevContext.register();\n    }\n  }));\n  (0, $goTMa$reactariautils.useSyncRef)(prevContext, ref);\n  (0, $goTMa$react.useEffect)(function () {\n    if (!isRegistered.current) {\n      console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n      isRegistered.current = true; // only warn once in strict mode.\n    }\n  }, []);\n  return /*#__PURE__*/(0, $parcel$interopDefault($goTMa$react)).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {\n    value: context\n  }, children);\n});\nfunction $3596bae48579386f$export$cf75428e0b9ed1ea(_ref7) {\n  var children = _ref7.children;\n  return /*#__PURE__*/(0, $parcel$interopDefault($goTMa$react)).createElement((0, $01d3f539e91688c8$export$5165eccb35aaadb5).Provider, {\n    value: undefined\n  }, children);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nvar $625cf83917e112ad$export$905e7fc544a71f36 = /*#__PURE__*/function () {\n  \"use strict\";\n\n  _createClass($625cf83917e112ad$export$905e7fc544a71f36, [{\n    key: \"isDefaultPrevented\",\n    value: function isDefaultPrevented() {\n      return this.nativeEvent.defaultPrevented;\n    }\n  }, {\n    key: \"preventDefault\",\n    value: function preventDefault() {\n      this.defaultPrevented = true;\n      this.nativeEvent.preventDefault();\n    }\n  }, {\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      this.nativeEvent.stopPropagation();\n      this.isPropagationStopped = function () {\n        return true;\n      };\n    }\n  }, {\n    key: \"isPropagationStopped\",\n    value: function isPropagationStopped() {\n      return false;\n    }\n  }, {\n    key: \"persist\",\n    value: function persist() {}\n  }]);\n  function $625cf83917e112ad$export$905e7fc544a71f36(type, nativeEvent) {\n    _classCallCheck(this, $625cf83917e112ad$export$905e7fc544a71f36);\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEvent.target;\n    this.currentTarget = nativeEvent.currentTarget;\n    this.relatedTarget = nativeEvent.relatedTarget;\n    this.bubbles = nativeEvent.bubbles;\n    this.cancelable = nativeEvent.cancelable;\n    this.defaultPrevented = nativeEvent.defaultPrevented;\n    this.eventPhase = nativeEvent.eventPhase;\n    this.isTrusted = nativeEvent.isTrusted;\n    this.timeStamp = nativeEvent.timeStamp;\n    this.type = type;\n  }\n  return $625cf83917e112ad$export$905e7fc544a71f36;\n}();\nfunction $625cf83917e112ad$export$715c682d09d639cc(onBlur) {\n  var stateRef = (0, $goTMa$react.useRef)({\n    isFocused: false,\n    observer: null\n  });\n  // Clean up MutationObserver on unmount. See below.\n  // eslint-disable-next-line arrow-body-style\n  (0, $goTMa$reactariautils.useLayoutEffect)(function () {\n    var state = stateRef.current;\n    return function () {\n      if (state.observer) {\n        state.observer.disconnect();\n        state.observer = null;\n      }\n    };\n  }, []);\n  var dispatchBlur = (0, $goTMa$reactariautils.useEffectEvent)(function (e) {\n    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);\n  });\n  // This function is called during a React onFocus event.\n  return (0, $goTMa$react.useCallback)(function (e) {\n    // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n    // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n    // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n    // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n    if (e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLSelectElement) {\n      stateRef.current.isFocused = true;\n      var target = e.target;\n      var onBlurHandler = function onBlurHandler(e) {\n        stateRef.current.isFocused = false;\n        if (target.disabled)\n          // For backward compatibility, dispatch a (fake) React synthetic event.\n          dispatchBlur(new $625cf83917e112ad$export$905e7fc544a71f36(\"blur\", e));\n        // We no longer need the MutationObserver once the target is blurred.\n        if (stateRef.current.observer) {\n          stateRef.current.observer.disconnect();\n          stateRef.current.observer = null;\n        }\n      };\n      target.addEventListener(\"focusout\", onBlurHandler, {\n        once: true\n      });\n      stateRef.current.observer = new MutationObserver(function () {\n        if (stateRef.current.isFocused && target.disabled) {\n          stateRef.current.observer.disconnect();\n          var relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent(\"blur\", {\n            relatedTarget: relatedTargetEl\n          }));\n          target.dispatchEvent(new FocusEvent(\"focusout\", {\n            bubbles: true,\n            relatedTarget: relatedTargetEl\n          }));\n        }\n      });\n      stateRef.current.observer.observe(target, {\n        attributes: true,\n        attributeFilter: [\"disabled\"]\n      });\n    }\n  }, [dispatchBlur]);\n}\nfunction $5cb73d0ce355b0dc$export$f8168d8dd8fd66e6(props) {\n  var isDisabled = props.isDisabled,\n    onFocusProp = props.onFocus,\n    onBlurProp = props.onBlur,\n    onFocusChange = props.onFocusChange;\n  var onBlur = (0, $goTMa$react.useCallback)(function (e) {\n    if (e.target === e.currentTarget) {\n      if (onBlurProp) onBlurProp(e);\n      if (onFocusChange) onFocusChange(false);\n      return true;\n    }\n  }, [onBlurProp, onFocusChange]);\n  var onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);\n  var onFocus = (0, $goTMa$react.useCallback)(function (e) {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (e.target === e.currentTarget && document.activeElement === e.target) {\n      if (onFocusProp) onFocusProp(e);\n      if (onFocusChange) onFocusChange(true);\n      onSyntheticFocus(e);\n    }\n  }, [onFocusChange, onFocusProp, onSyntheticFocus]);\n  return {\n    focusProps: {\n      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : undefined\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nvar $e77252a287ef94ab$var$currentModality = null;\nvar $e77252a287ef94ab$var$changeHandlers = new Set();\nvar $e77252a287ef94ab$var$hasSetupGlobalListeners = false;\nvar $e77252a287ef94ab$var$hasEventBeforeFocus = false;\nvar $e77252a287ef94ab$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nvar $e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: true,\n  Escape: true\n};\nfunction $e77252a287ef94ab$var$triggerChangeHandlers(modality, e) {\n  var _iterator2 = _createForOfIteratorHelper($e77252a287ef94ab$var$changeHandlers),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var handler = _step2.value;\n      handler(modality, e);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */\nfunction $e77252a287ef94ab$var$isValidKey(e) {\n  // Control and Shift keys trigger when navigating back to the tab with keyboard.\n  return !(e.metaKey || !(0, $goTMa$reactariautils.isMac)() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n}\nfunction $e77252a287ef94ab$var$handleKeyboardEvent(e) {\n  $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n  if ($e77252a287ef94ab$var$isValidKey(e)) {\n    $e77252a287ef94ab$var$currentModality = \"keyboard\";\n    $e77252a287ef94ab$var$triggerChangeHandlers(\"keyboard\", e);\n  }\n}\nfunction $e77252a287ef94ab$var$handlePointerEvent(e) {\n  $e77252a287ef94ab$var$currentModality = \"pointer\";\n  if (e.type === \"mousedown\" || e.type === \"pointerdown\") {\n    $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n    $e77252a287ef94ab$var$triggerChangeHandlers(\"pointer\", e);\n  }\n}\nfunction $e77252a287ef94ab$var$handleClickEvent(e) {\n  if ((0, $goTMa$reactariautils.isVirtualClick)(e)) {\n    $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n    $e77252a287ef94ab$var$currentModality = \"virtual\";\n  }\n}\nfunction $e77252a287ef94ab$var$handleFocusEvent(e) {\n  // Firefox fires two extra focus events when the user first clicks into an iframe:\n  // first on the window, then on the document. We ignore these events so they don't\n  // cause keyboard focus rings to appear.\n  if (e.target === window || e.target === document) return;\n  // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n  // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n  if (!$e77252a287ef94ab$var$hasEventBeforeFocus && !$e77252a287ef94ab$var$hasBlurredWindowRecently) {\n    $e77252a287ef94ab$var$currentModality = \"virtual\";\n    $e77252a287ef94ab$var$triggerChangeHandlers(\"virtual\", e);\n  }\n  $e77252a287ef94ab$var$hasEventBeforeFocus = false;\n  $e77252a287ef94ab$var$hasBlurredWindowRecently = false;\n}\nfunction $e77252a287ef94ab$var$handleWindowBlur() {\n  // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n  // for example, since a subsequent focus event won't be fired.\n  $e77252a287ef94ab$var$hasEventBeforeFocus = false;\n  $e77252a287ef94ab$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */\nfunction $e77252a287ef94ab$var$setupGlobalFocusEvents() {\n  if (typeof window === \"undefined\" || $e77252a287ef94ab$var$hasSetupGlobalListeners) return;\n  // Programmatic focus() calls shouldn't affect the current input modality.\n  // However, we need to detect other cases when a focus event occurs without\n  // a preceding user event (e.g. screen reader focus). Overriding the focus\n  // method on HTMLElement.prototype is a bit hacky, but works.\n  var focus = HTMLElement.prototype.focus;\n  HTMLElement.prototype.focus = function () {\n    $e77252a287ef94ab$var$hasEventBeforeFocus = true;\n    focus.apply(this, arguments);\n  };\n  document.addEventListener(\"keydown\", $e77252a287ef94ab$var$handleKeyboardEvent, true);\n  document.addEventListener(\"keyup\", $e77252a287ef94ab$var$handleKeyboardEvent, true);\n  document.addEventListener(\"click\", $e77252a287ef94ab$var$handleClickEvent, true);\n  // Register focus events on the window so they are sure to happen\n  // before React's event listeners (registered on the document).\n  window.addEventListener(\"focus\", $e77252a287ef94ab$var$handleFocusEvent, true);\n  window.addEventListener(\"blur\", $e77252a287ef94ab$var$handleWindowBlur, false);\n  if (typeof PointerEvent !== \"undefined\") {\n    document.addEventListener(\"pointerdown\", $e77252a287ef94ab$var$handlePointerEvent, true);\n    document.addEventListener(\"pointermove\", $e77252a287ef94ab$var$handlePointerEvent, true);\n    document.addEventListener(\"pointerup\", $e77252a287ef94ab$var$handlePointerEvent, true);\n  } else {\n    document.addEventListener(\"mousedown\", $e77252a287ef94ab$var$handlePointerEvent, true);\n    document.addEventListener(\"mousemove\", $e77252a287ef94ab$var$handlePointerEvent, true);\n    document.addEventListener(\"mouseup\", $e77252a287ef94ab$var$handlePointerEvent, true);\n  }\n  $e77252a287ef94ab$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== \"undefined\") {\n  if (document.readyState !== \"loading\") $e77252a287ef94ab$var$setupGlobalFocusEvents();else document.addEventListener(\"DOMContentLoaded\", $e77252a287ef94ab$var$setupGlobalFocusEvents);\n}\nfunction $e77252a287ef94ab$export$b9b3dfddab17db27() {\n  return $e77252a287ef94ab$var$currentModality !== \"pointer\";\n}\nfunction $e77252a287ef94ab$export$630ff653c5ada6a9() {\n  return $e77252a287ef94ab$var$currentModality;\n}\nfunction $e77252a287ef94ab$export$8397ddfc504fdb9a(modality) {\n  $e77252a287ef94ab$var$currentModality = modality;\n  $e77252a287ef94ab$var$triggerChangeHandlers(modality, null);\n}\nfunction $e77252a287ef94ab$export$98e20ec92f614cfe() {\n  $e77252a287ef94ab$var$setupGlobalFocusEvents();\n  var _ref8 = (0, $goTMa$react.useState)($e77252a287ef94ab$var$currentModality),\n    _ref9 = _slicedToArray(_ref8, 2),\n    modality = _ref9[0],\n    setModality = _ref9[1];\n  (0, $goTMa$react.useEffect)(function () {\n    var handler = function handler() {\n      setModality($e77252a287ef94ab$var$currentModality);\n    };\n    $e77252a287ef94ab$var$changeHandlers.add(handler);\n    return function () {\n      $e77252a287ef94ab$var$changeHandlers.delete(handler);\n    };\n  }, []);\n  return (0, $goTMa$reactariassr.useIsSSR)() ? null : modality;\n}\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */\nfunction $e77252a287ef94ab$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n  return !(isTextInput && modality === \"keyboard\" && e instanceof KeyboardEvent && !$e77252a287ef94ab$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $e77252a287ef94ab$export$ffd9e5021c1fb2d6() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var isTextInput = props.isTextInput,\n    autoFocus = props.autoFocus;\n  var _ref10 = (0, $goTMa$react.useState)(autoFocus || $e77252a287ef94ab$export$b9b3dfddab17db27()),\n    _ref11 = _slicedToArray(_ref10, 2),\n    isFocusVisibleState = _ref11[0],\n    setFocusVisible = _ref11[1];\n  $e77252a287ef94ab$export$ec71b4b83ac08ec3(function (isFocusVisible) {\n    setFocusVisible(isFocusVisible);\n  }, [isTextInput], {\n    isTextInput: isTextInput\n  });\n  return {\n    isFocusVisible: isFocusVisibleState\n  };\n}\nfunction $e77252a287ef94ab$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $e77252a287ef94ab$var$setupGlobalFocusEvents();\n  (0, $goTMa$react.useEffect)(function () {\n    var handler = function handler(modality, e) {\n      if (!$e77252a287ef94ab$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;\n      fn($e77252a287ef94ab$export$b9b3dfddab17db27());\n    };\n    $e77252a287ef94ab$var$changeHandlers.add(handler);\n    return function () {\n      $e77252a287ef94ab$var$changeHandlers.delete(handler);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $d16842bbd0359d1b$export$420e68273165f4ec(props) {\n  var isDisabled = props.isDisabled,\n    onBlurWithin = props.onBlurWithin,\n    onFocusWithin = props.onFocusWithin,\n    onFocusWithinChange = props.onFocusWithinChange;\n  var state = (0, $goTMa$react.useRef)({\n    isFocusWithin: false\n  });\n  var onBlur = (0, $goTMa$react.useCallback)(function (e) {\n    // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n    // when moving focus inside the element. Only trigger if the currentTarget doesn't\n    // include the relatedTarget (where focus is moving).\n    if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n      state.current.isFocusWithin = false;\n      if (onBlurWithin) onBlurWithin(e);\n      if (onFocusWithinChange) onFocusWithinChange(false);\n    }\n  }, [onBlurWithin, onFocusWithinChange, state]);\n  var onSyntheticFocus = (0, $625cf83917e112ad$export$715c682d09d639cc)(onBlur);\n  var onFocus = (0, $goTMa$react.useCallback)(function (e) {\n    // Double check that document.activeElement actually matches e.target in case a previously chained\n    // focus handler already moved focus somewhere else.\n    if (!state.current.isFocusWithin && document.activeElement === e.target) {\n      if (onFocusWithin) onFocusWithin(e);\n      if (onFocusWithinChange) onFocusWithinChange(true);\n      state.current.isFocusWithin = true;\n      onSyntheticFocus(e);\n    }\n  }, [onFocusWithin, onFocusWithinChange, onSyntheticFocus]);\n  if (isDisabled) return {\n    focusWithinProps: {\n      onFocus: null,\n      onBlur: null\n    }\n  };\n  return {\n    focusWithinProps: {\n      onFocus: onFocus,\n      onBlur: onBlur\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nvar $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;\nvar $ffbc150311c75f01$var$hoverCount = 0;\nfunction $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents() {\n  $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = true;\n  // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n  // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n  // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n  // the distant future because a user previously touched the element.\n  setTimeout(function () {\n    $ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents = false;\n  }, 50);\n}\nfunction $ffbc150311c75f01$var$handleGlobalPointerEvent(e) {\n  if (e.pointerType === \"touch\") $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $ffbc150311c75f01$var$setupGlobalTouchEvents() {\n  if (typeof document === \"undefined\") return;\n  if (typeof PointerEvent !== \"undefined\") document.addEventListener(\"pointerup\", $ffbc150311c75f01$var$handleGlobalPointerEvent);else document.addEventListener(\"touchend\", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);\n  $ffbc150311c75f01$var$hoverCount++;\n  return function () {\n    $ffbc150311c75f01$var$hoverCount--;\n    if ($ffbc150311c75f01$var$hoverCount > 0) return;\n    if (typeof PointerEvent !== \"undefined\") document.removeEventListener(\"pointerup\", $ffbc150311c75f01$var$handleGlobalPointerEvent);else document.removeEventListener(\"touchend\", $ffbc150311c75f01$var$setGlobalIgnoreEmulatedMouseEvents);\n  };\n}\nfunction $ffbc150311c75f01$export$ae780daf29e6d456(props) {\n  var onHoverStart = props.onHoverStart,\n    onHoverChange = props.onHoverChange,\n    onHoverEnd = props.onHoverEnd,\n    isDisabled = props.isDisabled;\n  var _ref12 = (0, $goTMa$react.useState)(false),\n    _ref13 = _slicedToArray(_ref12, 2),\n    isHovered = _ref13[0],\n    setHovered = _ref13[1];\n  var state = (0, $goTMa$react.useRef)({\n    isHovered: false,\n    ignoreEmulatedMouseEvents: false,\n    pointerType: \"\",\n    target: null\n  }).current;\n  (0, $goTMa$react.useEffect)($ffbc150311c75f01$var$setupGlobalTouchEvents, []);\n  var _ref14 = (0, $goTMa$react.useMemo)(function () {\n      var triggerHoverStart = function triggerHoverStart(event, pointerType) {\n        state.pointerType = pointerType;\n        if (isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n        state.isHovered = true;\n        var target = event.currentTarget;\n        state.target = target;\n        if (onHoverStart) onHoverStart({\n          type: \"hoverstart\",\n          target: target,\n          pointerType: pointerType\n        });\n        if (onHoverChange) onHoverChange(true);\n        setHovered(true);\n      };\n      var triggerHoverEnd = function triggerHoverEnd(event, pointerType) {\n        state.pointerType = \"\";\n        state.target = null;\n        if (pointerType === \"touch\" || !state.isHovered) return;\n        state.isHovered = false;\n        var target = event.currentTarget;\n        if (onHoverEnd) onHoverEnd({\n          type: \"hoverend\",\n          target: target,\n          pointerType: pointerType\n        });\n        if (onHoverChange) onHoverChange(false);\n        setHovered(false);\n      };\n      var hoverProps = {};\n      if (typeof PointerEvent !== \"undefined\") {\n        hoverProps.onPointerEnter = function (e) {\n          if ($ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents && e.pointerType === \"mouse\") return;\n          triggerHoverStart(e, e.pointerType);\n        };\n        hoverProps.onPointerLeave = function (e) {\n          if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n        };\n      } else {\n        hoverProps.onTouchStart = function () {\n          state.ignoreEmulatedMouseEvents = true;\n        };\n        hoverProps.onMouseEnter = function (e) {\n          if (!state.ignoreEmulatedMouseEvents && !$ffbc150311c75f01$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, \"mouse\");\n          state.ignoreEmulatedMouseEvents = false;\n        };\n        hoverProps.onMouseLeave = function (e) {\n          if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, \"mouse\");\n        };\n      }\n      return {\n        hoverProps: hoverProps,\n        triggerHoverEnd: triggerHoverEnd\n      };\n    }, [onHoverStart, onHoverChange, onHoverEnd, isDisabled, state]),\n    hoverProps = _ref14.hoverProps,\n    triggerHoverEnd = _ref14.triggerHoverEnd;\n  (0, $goTMa$react.useEffect)(function () {\n    // Call the triggerHoverEnd as soon as isDisabled changes to true\n    // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n    if (isDisabled) triggerHoverEnd({\n      currentTarget: state.target\n    }, state.pointerType);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isDisabled]);\n  return {\n    hoverProps: hoverProps,\n    isHovered: isHovered\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Portions of the code in this file are based on code from react.\n// Original licensing for the following can be found in the\n// NOTICE file in the root directory of this source tree.\n// See https://github.com/facebook/react/tree/cc7c1aece46a6b69b41958d731e0fd27c94bfc6c/packages/react-interactions\n\nfunction $edcfa848c42f94f4$export$872b660ac5a1ff98(props) {\n  var ref = props.ref,\n    onInteractOutside = props.onInteractOutside,\n    isDisabled = props.isDisabled,\n    onInteractOutsideStart = props.onInteractOutsideStart;\n  var stateRef = (0, $goTMa$react.useRef)({\n    isPointerDown: false,\n    ignoreEmulatedMouseEvents: false\n  });\n  var onPointerDown = (0, $goTMa$reactariautils.useEffectEvent)(function (e) {\n    if (onInteractOutside && $edcfa848c42f94f4$var$isValidEvent(e, ref)) {\n      if (onInteractOutsideStart) onInteractOutsideStart(e);\n      stateRef.current.isPointerDown = true;\n    }\n  });\n  var triggerInteractOutside = (0, $goTMa$reactariautils.useEffectEvent)(function (e) {\n    if (onInteractOutside) onInteractOutside(e);\n  });\n  (0, $goTMa$react.useEffect)(function () {\n    var state = stateRef.current;\n    if (isDisabled) return;\n    // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n    if (typeof PointerEvent !== \"undefined\") {\n      var onPointerUp = function onPointerUp(e) {\n        if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      // changing these to capture phase fixed combobox\n      document.addEventListener(\"pointerdown\", onPointerDown, true);\n      document.addEventListener(\"pointerup\", onPointerUp, true);\n      return function () {\n        document.removeEventListener(\"pointerdown\", onPointerDown, true);\n        document.removeEventListener(\"pointerup\", onPointerUp, true);\n      };\n    } else {\n      var onMouseUp = function onMouseUp(e) {\n        if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;else if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      var onTouchEnd = function onTouchEnd(e) {\n        state.ignoreEmulatedMouseEvents = true;\n        if (state.isPointerDown && $edcfa848c42f94f4$var$isValidEvent(e, ref)) triggerInteractOutside(e);\n        state.isPointerDown = false;\n      };\n      document.addEventListener(\"mousedown\", onPointerDown, true);\n      document.addEventListener(\"mouseup\", onMouseUp, true);\n      document.addEventListener(\"touchstart\", onPointerDown, true);\n      document.addEventListener(\"touchend\", onTouchEnd, true);\n      return function () {\n        document.removeEventListener(\"mousedown\", onPointerDown, true);\n        document.removeEventListener(\"mouseup\", onMouseUp, true);\n        document.removeEventListener(\"touchstart\", onPointerDown, true);\n        document.removeEventListener(\"touchend\", onTouchEnd, true);\n      };\n    }\n  }, [ref, isDisabled, onPointerDown, triggerInteractOutside]);\n}\nfunction $edcfa848c42f94f4$var$isValidEvent(event, ref) {\n  if (event.button > 0) return false;\n  if (event.target) {\n    // if the event target is no longer in the document, ignore\n    var ownerDocument = event.target.ownerDocument;\n    if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n    // If the target is within a top layer element (e.g. toasts), ignore.\n    if (event.target.closest(\"[data-react-aria-top-layer]\")) return false;\n  }\n  return ref.current && !ref.current.contains(event.target);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ /*\n    * Copyright 2020 Adobe. All rights reserved.\n    * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n    * you may not use this file except in compliance with the License. You may obtain a copy\n    * of the License at http://www.apache.org/licenses/LICENSE-2.0\n    *\n    * Unless required by applicable law or agreed to in writing, software distributed under\n    * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n    * OF ANY KIND, either express or implied. See the License for the specific language\n    * governing permissions and limitations under the License.\n    */\nfunction $951fbcbbca8db6ce$export$48d1ea6320830260(handler) {\n  if (!handler) return;\n  var shouldStopPropagation = true;\n  return function (e) {\n    var event = _objectSpread({}, e, {\n      preventDefault: function preventDefault() {\n        e.preventDefault();\n      },\n      isDefaultPrevented: function isDefaultPrevented() {\n        return e.isDefaultPrevented();\n      },\n      stopPropagation: function stopPropagation() {\n        console.error(\"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.\");\n      },\n      continuePropagation: function continuePropagation() {\n        shouldStopPropagation = false;\n      }\n    });\n    handler(event);\n    if (shouldStopPropagation) e.stopPropagation();\n  };\n}\nfunction $892d64db2a3c53b0$export$8f71654801c2f7cd(props) {\n  return {\n    keyboardProps: props.isDisabled ? {} : {\n      onKeyDown: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyDown),\n      onKeyUp: (0, $951fbcbbca8db6ce$export$48d1ea6320830260)(props.onKeyUp)\n    }\n  };\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $c09386fc48fa427d$export$36da96379f79f245(props) {\n  var onMoveStart = props.onMoveStart,\n    onMove = props.onMove,\n    onMoveEnd = props.onMoveEnd;\n  var state = (0, $goTMa$react.useRef)({\n    didMove: false,\n    lastPosition: null,\n    id: null\n  });\n  var _ref15 = (0, $goTMa$reactariautils.useGlobalListeners)(),\n    addGlobalListener = _ref15.addGlobalListener,\n    removeGlobalListener = _ref15.removeGlobalListener;\n  var move = (0, $goTMa$reactariautils.useEffectEvent)(function (originalEvent, pointerType, deltaX, deltaY) {\n    if (deltaX === 0 && deltaY === 0) return;\n    if (!state.current.didMove) {\n      state.current.didMove = true;\n      onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n        type: \"movestart\",\n        pointerType: pointerType,\n        shiftKey: originalEvent.shiftKey,\n        metaKey: originalEvent.metaKey,\n        ctrlKey: originalEvent.ctrlKey,\n        altKey: originalEvent.altKey\n      });\n    }\n    onMove({\n      type: \"move\",\n      pointerType: pointerType,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      shiftKey: originalEvent.shiftKey,\n      metaKey: originalEvent.metaKey,\n      ctrlKey: originalEvent.ctrlKey,\n      altKey: originalEvent.altKey\n    });\n  });\n  var end = (0, $goTMa$reactariautils.useEffectEvent)(function (originalEvent, pointerType) {\n    (0, $f7e14e656343df57$export$b0d6fa1ab32e3295)();\n    if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n      type: \"moveend\",\n      pointerType: pointerType,\n      shiftKey: originalEvent.shiftKey,\n      metaKey: originalEvent.metaKey,\n      ctrlKey: originalEvent.ctrlKey,\n      altKey: originalEvent.altKey\n    });\n  });\n  var moveProps = (0, $goTMa$react.useMemo)(function () {\n    var moveProps = {};\n    var start = function start() {\n      (0, $f7e14e656343df57$export$16a4697467175487)();\n      state.current.didMove = false;\n    };\n    if (typeof PointerEvent === \"undefined\") {\n      var onMouseMove = function onMouseMove(e) {\n        if (e.button === 0) {\n          move(e, \"mouse\", e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);\n          state.current.lastPosition = {\n            pageX: e.pageX,\n            pageY: e.pageY\n          };\n        }\n      };\n      var onMouseUp = function onMouseUp(e) {\n        if (e.button === 0) {\n          end(e, \"mouse\");\n          removeGlobalListener(window, \"mousemove\", onMouseMove, false);\n          removeGlobalListener(window, \"mouseup\", onMouseUp, false);\n        }\n      };\n      moveProps.onMouseDown = function (e) {\n        if (e.button === 0) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {\n            pageX: e.pageX,\n            pageY: e.pageY\n          };\n          addGlobalListener(window, \"mousemove\", onMouseMove, false);\n          addGlobalListener(window, \"mouseup\", onMouseUp, false);\n        }\n      };\n      var onTouchMove = function onTouchMove(e) {\n        var touch = _toConsumableArray(e.changedTouches).findIndex(function (_ref16) {\n          var identifier = _ref16.identifier;\n          return identifier === state.current.id;\n        });\n        if (touch >= 0) {\n          var _e$changedTouches$tou = e.changedTouches[touch],\n            pageX = _e$changedTouches$tou.pageX,\n            pageY = _e$changedTouches$tou.pageY;\n          move(e, \"touch\", pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);\n          state.current.lastPosition = {\n            pageX: pageX,\n            pageY: pageY\n          };\n        }\n      };\n      var onTouchEnd = function onTouchEnd(e) {\n        var touch = _toConsumableArray(e.changedTouches).findIndex(function (_ref17) {\n          var identifier = _ref17.identifier;\n          return identifier === state.current.id;\n        });\n        if (touch >= 0) {\n          end(e, \"touch\");\n          state.current.id = null;\n          removeGlobalListener(window, \"touchmove\", onTouchMove);\n          removeGlobalListener(window, \"touchend\", onTouchEnd);\n          removeGlobalListener(window, \"touchcancel\", onTouchEnd);\n        }\n      };\n      moveProps.onTouchStart = function (e) {\n        if (e.changedTouches.length === 0 || state.current.id != null) return;\n        var _e$changedTouches$ = e.changedTouches[0],\n          pageX = _e$changedTouches$.pageX,\n          pageY = _e$changedTouches$.pageY,\n          identifier = _e$changedTouches$.identifier;\n        start();\n        e.stopPropagation();\n        e.preventDefault();\n        state.current.lastPosition = {\n          pageX: pageX,\n          pageY: pageY\n        };\n        state.current.id = identifier;\n        addGlobalListener(window, \"touchmove\", onTouchMove, false);\n        addGlobalListener(window, \"touchend\", onTouchEnd, false);\n        addGlobalListener(window, \"touchcancel\", onTouchEnd, false);\n      };\n    } else {\n      var onPointerMove = function onPointerMove(e) {\n        if (e.pointerId === state.current.id) {\n          var pointerType = e.pointerType || \"mouse\";\n          // Problems with PointerEvent#movementX/movementY:\n          // 1. it is always 0 on macOS Safari.\n          // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n          move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);\n          state.current.lastPosition = {\n            pageX: e.pageX,\n            pageY: e.pageY\n          };\n        }\n      };\n      var onPointerUp = function onPointerUp(e) {\n        if (e.pointerId === state.current.id) {\n          var pointerType = e.pointerType || \"mouse\";\n          end(e, pointerType);\n          state.current.id = null;\n          removeGlobalListener(window, \"pointermove\", onPointerMove, false);\n          removeGlobalListener(window, \"pointerup\", onPointerUp, false);\n          removeGlobalListener(window, \"pointercancel\", onPointerUp, false);\n        }\n      };\n      moveProps.onPointerDown = function (e) {\n        if (e.button === 0 && state.current.id == null) {\n          start();\n          e.stopPropagation();\n          e.preventDefault();\n          state.current.lastPosition = {\n            pageX: e.pageX,\n            pageY: e.pageY\n          };\n          state.current.id = e.pointerId;\n          addGlobalListener(window, \"pointermove\", onPointerMove, false);\n          addGlobalListener(window, \"pointerup\", onPointerUp, false);\n          addGlobalListener(window, \"pointercancel\", onPointerUp, false);\n        }\n      };\n    }\n    var triggerKeyboardMove = function triggerKeyboardMove(e, deltaX, deltaY) {\n      start();\n      move(e, \"keyboard\", deltaX, deltaY);\n      end(e, \"keyboard\");\n    };\n    moveProps.onKeyDown = function (e) {\n      switch (e.key) {\n        case \"Left\":\n        case \"ArrowLeft\":\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, -1, 0);\n          break;\n        case \"Right\":\n        case \"ArrowRight\":\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 1, 0);\n          break;\n        case \"Up\":\n        case \"ArrowUp\":\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, -1);\n          break;\n        case \"Down\":\n        case \"ArrowDown\":\n          e.preventDefault();\n          e.stopPropagation();\n          triggerKeyboardMove(e, 0, 1);\n          break;\n      }\n    };\n    return moveProps;\n  }, [state, addGlobalListener, removeGlobalListener, move, end]);\n  return {\n    moveProps: moveProps\n  };\n}\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $a3dbce0aed7087e2$export$2123ff2b87c81ca(props, ref) {\n  var onScroll = props.onScroll,\n    isDisabled = props.isDisabled;\n  var onScrollHandler = (0, $goTMa$react.useCallback)(function (e) {\n    // If the ctrlKey is pressed, this is a zoom event, do nothing.\n    if (e.ctrlKey) return;\n    // stop scrolling the page\n    e.preventDefault();\n    e.stopPropagation();\n    if (onScroll) onScroll({\n      deltaX: e.deltaX,\n      deltaY: e.deltaY\n    });\n  }, [onScroll]);\n  (0, $goTMa$reactariautils.useEvent)(ref, \"wheel\", isDisabled ? null : onScrollHandler);\n}\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nvar $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD = 500;\nfunction $3cd7b5d0eebf0ca9$export$c24ed0104d07eab9(props) {\n  var isDisabled = props.isDisabled,\n    onLongPressStart = props.onLongPressStart,\n    onLongPressEnd = props.onLongPressEnd,\n    onLongPress = props.onLongPress,\n    _props$threshold = props.threshold,\n    threshold = _props$threshold === void 0 ? $3cd7b5d0eebf0ca9$var$DEFAULT_THRESHOLD : _props$threshold,\n    accessibilityDescription = props.accessibilityDescription;\n  var timeRef = (0, $goTMa$react.useRef)(null);\n  var _ref18 = (0, $goTMa$reactariautils.useGlobalListeners)(),\n    addGlobalListener = _ref18.addGlobalListener,\n    removeGlobalListener = _ref18.removeGlobalListener;\n  var _ref19 = (0, $0294ea432cd92340$export$45712eceda6fad21)({\n      isDisabled: isDisabled,\n      onPressStart: function onPressStart(e) {\n        e.continuePropagation();\n        if (e.pointerType === \"mouse\" || e.pointerType === \"touch\") {\n          if (onLongPressStart) onLongPressStart(_objectSpread({}, e, {\n            type: \"longpressstart\"\n          }));\n          timeRef.current = setTimeout(function () {\n            // Prevent other usePress handlers from also handling this event.\n            e.target.dispatchEvent(new PointerEvent(\"pointercancel\", {\n              bubbles: true\n            }));\n            if (onLongPress) onLongPress(_objectSpread({}, e, {\n              type: \"longpress\"\n            }));\n            timeRef.current = null;\n          }, threshold);\n          // Prevent context menu, which may be opened on long press on touch devices\n          if (e.pointerType === \"touch\") {\n            var onContextMenu = function onContextMenu(e) {\n              e.preventDefault();\n            };\n            addGlobalListener(e.target, \"contextmenu\", onContextMenu, {\n              once: true\n            });\n            addGlobalListener(window, \"pointerup\", function () {\n              // If no contextmenu event is fired quickly after pointerup, remove the handler\n              // so future context menu events outside a long press are not prevented.\n              setTimeout(function () {\n                removeGlobalListener(e.target, \"contextmenu\", onContextMenu);\n              }, 30);\n            }, {\n              once: true\n            });\n          }\n        }\n      },\n      onPressEnd: function onPressEnd(e) {\n        if (timeRef.current) clearTimeout(timeRef.current);\n        if (onLongPressEnd && (e.pointerType === \"mouse\" || e.pointerType === \"touch\")) onLongPressEnd(_objectSpread({}, e, {\n          type: \"longpressend\"\n        }));\n      }\n    }),\n    pressProps = _ref19.pressProps;\n  var descriptionProps = (0, $goTMa$reactariautils.useDescription)(onLongPress && !isDisabled ? accessibilityDescription : null);\n  return {\n    longPressProps: (0, $goTMa$reactariautils.mergeProps)(pressProps, descriptionProps)\n  };\n}","map":null,"metadata":{},"sourceType":"script"}